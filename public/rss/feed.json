{
    "version": "https://jsonfeed.org/version/1",
    "title": "Suraj Adsul's Blog",
    "home_page_url": "https://surajadsul.com",
    "description": "Articles about software development, technology, and personal experiences",
    "icon": "https://surajadsul.com/images/profile.jpg",
    "author": {
        "name": "Suraj Adsul",
        "url": "https://surajadsul.com"
    },
    "items": [
        {
            "id": "https://surajadsul.com/blog/conquering_the_css_nightmare_as_a_backend_engineer",
            "content_html": "\nIt's been a long time since I last wrote an article, and since this crazy time started, I hope all of you are doing well and coping with the pandemic situation.\n\n## My Journey into UI Development\n\nI started my professional career as a full-stack engineer but mostly focused on backend development. While I used Bootstrap and some UI libraries to quickly build interfaces, I never had full control over the UI. Most people found my work impressive at the time, but deep down, I felt guilty relying on heavy libraries with limited flexibility.\n\nIf you have a good UI/UX sense, these libraries often feel restrictive. So, I attempted to learn CSS—but coming from a backend background, it was far from enjoyable. Writing CSS felt unintuitive, requiring too much effort just to name reusable classes, and yet, the results still felt unstructured.\n\n## The Struggle with CSS\n\nDespite my love for well-designed UIs, writing CSS felt like a nightmare. Learning Vue.js or React was much easier compared to styling. Most backend engineers I knew shared the same fear—CSS seemed difficult because we rarely had to write it from scratch. Instead, we often copy-pasted components and moved on.\n\nI spent countless hours browsing Dribbble and admiring beautiful UIs from companies like Netflix, Stripe, and Spotify, wondering if I would ever be able to create something similar. My frustration led me to tools like Adobe XD and Figma, where I enjoyed designing interfaces. But I still had one major problem: I couldn't translate those designs into code.\n\n## The Turning Point: Discovering Tailwind CSS\n\nFast forward a few years, and Adam Wathan introduced Tailwind CSS. As a long-time Laravel community follower, I decided to give it a shot. At first, using Tailwind felt difficult due to my limited CSS knowledge. However, its utility-first approach made styling more intuitive and enjoyable. For the first time, writing CSS felt fun!\n\nI started implementing different designs using Tailwind, and it was a game-changer. With its content-agnostic classes, I could build UI components much faster without losing control over styling. I finally had the power of raw CSS without the usual struggles.\n\n## Cloning Websites and Mastering UI\n\nTo practice, I began cloning popular websites like Spotify, Myntra, Facebook, Hotstar, Netflix, and Amazon. This approach taught me advanced CSS concepts like animations, blending modes, and responsiveness. Thanks to Tailwind CSS, replicating UIs became an enjoyable learning experience instead of a frustrating chore.\n\nInitially, it took me 2-3 days to clone a website. But with practice, I could recreate complex UIs in just a few hours. My fear of CSS was finally gone!\n\n## Why Tailwind CSS?\n\n### Pros:\n- Provides utility classes with full UI control.\n- Intuitive syntax that reduces cognitive load and boosts productivity.\n- Fun and easy to write.\n- Includes PurgeCSS, ensuring only used classes are included in the production build.\n- Encourages component-based thinking.\n- Well-thought-out utility classes and color palettes.\n- Fully customizable.\n- Simplifies animations, gradients, and blending modes.\n- Built-in dark mode support.\n- Just-In-Time (JIT) mode for arbitrary styles.\n- Supports presets for maintaining design consistency across projects.\n\n### Cons:\n- Results in numerous classes in your HTML.\n  - However, with modern JavaScript frameworks and Blade templates, component-based structuring helps mitigate this issue.\n- Still requires fundamental CSS knowledge.\n  - If you just want a quick prototype without dealing with CSS, Bootstrap or Foundation may be better options.\n\nThat said, I still recommend Tailwind CSS, even for prototyping. There are plenty of ready-made Tailwind component libraries available to speed up development while maintaining full UI control.\n\n## Useful Tailwind CSS Resources\n\n- **Official Tailwind UI (Paid)**: [https://tailwindui.com/](https://tailwindui.com/)\n- **Free Tailwind Component Libraries**:\n  - [https://tailblocks.cc/](https://tailblocks.cc/)\n  - [https://merakiui.com/](https://merakiui.com/)\n  - [https://www.creative-tim.com/learning-lab/tailwind-starter-kit/presentation](https://www.creative-tim.com/learning-lab/tailwind-starter-kit/presentation)\n\n## Final Thoughts\n\nIf you're like me—someone who loves great UI but struggled with CSS—I encourage you to try Tailwind CSS. Work on sample projects, find inspiration on Dribbble, and start experimenting. It may just change the way you approach frontend development, as it did for me.\n\n\n",
            "url": "https://surajadsul.com/blog/conquering_the_css_nightmare_as_a_backend_engineer",
            "title": "Conquering the CSS Nightmare as a Backend Engineer",
            "summary": "A journey from struggling with CSS to mastering UI development using Tailwind CSS. Learn how a backend engineer overcame the fear of styling and embraced frontend design.",
            "date_modified": "2021-05-29T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.com"
            }
        },
        {
            "id": "https://surajadsul.com/blog/creating_worklogs_using_cursor_ai_editor",
            "content_html": "\nKeeping a structured and detailed worklog is essential for tracking progress, maintaining accountability, and improving productivity. The Cursor AI editor provides an efficient way to maintain daily worklogs with a predefined structure. This guide outlines the best practices for creating and managing worklogs using Cursor AI.\n\n## Worklog Format and Structure\nEach daily worklog should follow a consistent structure for clarity and ease of reference. The format should be as follows:\n\n```markdown\n# Daily Worklog - [YYYY-MM-DD]\n\n## Summary\n- Brief overview of the day's main accomplishments\n- Key decisions made\n- Any blockers encountered\n\n## Tasks Completed\n- [x] Task 1\n  - Details/Implementation notes\n- [x] Task 2\n  - Details/Implementation notes\n\n## In Progress\n- [ ] Ongoing task 1\n  - Current status\n  - Next steps\n\n## Blockers/Issues\n- List any blockers or issues encountered\n- Include potential solutions or workarounds\n\n## Notes\n- Additional important information\n- Links to relevant resources\n- Meeting notes or decisions\n\n## Tomorrow's Plan\n- [ ] Planned task 1\n- [ ] Planned task 2\n\n## Time Tracking\n- Task 1: X hours\n- Task 2: Y hours\n\n\n## Worklog Guidelines\nTo maintain consistency and organization, adhere to these guidelines:\n\n1. **Date Format**: Always use `YYYY-MM-DD` (e.g., `2024-03-21`).\n2. **Storage Location**: Store worklogs in the directory structure `docs/worklogs/YYYY-MM/YYYY-MM-DD.md`.\n3. **Naming Convention**: Use lowercase filenames and adhere to the `YYYY-MM-DD.md` format.\n4. **Task Status**: Use `- [ ]` for incomplete tasks and `- [x]` for completed tasks.\n5. **Time Tracking**: Always include time spent on major tasks for better time management.\n6. **Links**: Include relevant links such as PRs, documentation, or meeting notes.\n7. **Blockers**: Clearly document any blockers, their status, and any attempted solutions.\n\n## Best Practices\nTo ensure your worklogs remain useful and effective, follow these best practices:\n\n1. **Start at the Beginning of the Day**: Outline planned tasks and priorities.\n2. **Update Throughout the Day**: Keep track of completed tasks and new developments.\n3. **Finalize at the End of the Day**: Review and ensure completeness before storing.\n4. **Include Technical Details**: Be specific about implementations, changes, and issues faced.\n5. **Reference Relevant Tickets/Issues**: Include issue numbers and descriptions where applicable.\n6. **Maintain Professionalism**: Use clear and professional language.\n7. **Document Decisions and Rationale**: Ensure clarity on why certain decisions were made.\n\n```\n\n## Conclusion\nBy using the Cursor AI editor to maintain structured and detailed worklogs, you can enhance productivity and ensure better documentation of your daily work. Following the outlined structure, guidelines, and best practices will make worklogs more effective and easier to review in the future.\n\n",
            "url": "https://surajadsul.com/blog/creating_worklogs_using_cursor_ai_editor",
            "title": "Creating Worklogs Using Cursor AI Editor",
            "summary": "Learn how to efficiently create and manage daily worklogs using the Cursor AI editor with a structured approach.",
            "date_modified": "2025-03-02T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.com"
            }
        },
        {
            "id": "https://surajadsul.com/blog/integrating_tailwind_css_in_a_legacy_project_using_the_standalone_executable",
            "content_html": "\n# Integrating Tailwind CSS in a Legacy Project Using the Standalone Executable\n\nIn a legacy project, integrating Tailwind CSS using the standalone executable instead of npm can be an effective approach. Here's how it can be implemented and why this method works well.\n\n## Implementation Approach\n\n### 1. Project Structure\n\nA structured approach to organizing Tailwind integration:\n\n```\nproject-root/\n├── tailwindcss (executable)\n├── public/\n│   └── css/\n│       ├── tailwind-input.css\n│       └── tailwind.css (generated)\n└── Makefile\n```\n\n### 2. Configuration Files\n\nA `tailwind-input.css` file can be created as the main configuration:\n\n```css\n@import 'tailwindcss/theme.css';\n@import 'tailwindcss/preflight.css';\n@import 'tailwindcss/utilities.css';\n@import './fonts.css' layer(base);\n@plugin \"@tailwindcss/aspect-ratio\";\n\n@theme {\n    --font-primary: Arial;\n    --font-secondary: Helvetica;\n    /* Custom theme variables */\n}\n\n@layer utilities {\n    /* Custom utility classes */\n    .container-custom {\n        margin-inline: auto !important;\n        width: 100% !important;\n        max-width: 640px !important;\n    }\n}\n```\n\n### 3. Build Process\n\nA simple Makefile can be used to manage Tailwind CSS compilation:\n\n```makefile\n.PHONY: watch build\n\nwatch:\n\t./tailwindcss -i ./public/css/tailwind-input.css -o ./public/css/tailwind.css --watch\n\nbuild:\n\t./tailwindcss -i ./public/css/tailwind-input.css -o ./public/css/tailwind.css --minify\n```\n\nCommands:\n- `make watch`: Watches for changes during development\n- `make build`: Creates a minified production version\n\n### 4. Integration with HTML\n\nThe compiled CSS file is included in templates:\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/tailwind.css?version=1.0.5\" />\n```\n\n## Key Benefits of This Approach\n\n1. **No npm Dependencies**: Avoids adding npm and its dependency tree.\n2. **Simple Build Process**: Requires only a single executable and a Makefile.\n3. **Easy Version Control**: The standalone executable can be managed separately.\n4. **Fast Compilation**: Optimized performance with the standalone executable.\n\n## Scoped Usage\n\nA clear approach to scope Tailwind CSS usage ensures maintainability:\n\n```markdown\nTailwindCSS is used exclusively in specific directories. \nFor other files, standard CSS is maintained.\n```\n\nThis scoped approach helps:\n- Maintain boundaries between legacy and modern CSS\n- Gradually introduce Tailwind CSS without disrupting existing styles\n- Keep the codebase structured and maintainable\n\n## Example Usage\n\nAn example of using Tailwind CSS:\n\n```html\n<div class=\"header-blue flex pl-10 font-primary text-white bg-gray-800 h-32 relative\">\n  <div class=\"absolute left-0 top-0 h-full w-5 bg-pattern bg-no-repeat bg-center\"></div>\n  <h1 class=\"ml-8 text-4xl md:text-5xl\">Sample Header</h1>\n</div>\n```\n\n## Best Practices\n\n1. **Version Control**: Track compiled CSS file versions using query parameters.\n2. **Scoped Implementation**: Use Tailwind CSS in designated directories.\n3. **Custom Utilities**: Create reusable utility classes as needed.\n4. **Build Process**: Use a Makefile for consistent builds across environments.\n\n## Conclusion\n\nUsing the Tailwind CSS standalone executable is an efficient way to modernize a legacy project's CSS without introducing complex dependencies. This approach enables the advantages of utility-first CSS while maintaining simplicity and compatibility with existing styles.\n\nThe key to success is maintaining clear boundaries between legacy and modern CSS patterns, allowing a gradual transition to modern styling practices while keeping the codebase structured and manageable.\n\n",
            "url": "https://surajadsul.com/blog/integrating_tailwind_css_in_a_legacy_project_using_the_standalone_executable",
            "title": "Integrating Tailwind CSS in a Legacy Project Using the Standalone Executable",
            "summary": "A step-by-step guide on integrating Tailwind CSS into a legacy project using the standalone executable. Learn how to set up the project structure, configure styles, and streamline the build process without relying on npm.",
            "date_modified": "2025-03-01T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.com"
            }
        },
        {
            "id": "https://surajadsul.com/blog/my_journey_with_cursor_ide",
            "content_html": "\nAs a developer who values both productivity and accuracy in time tracking, I embarked on a journey to create AI Harvest Timesheet, an innovative application that bridges the gap between Git commits and Harvest time entries. In this blog post, I'll share my experience building this application using Cursor, a cutting-edge IDE that made the development process smoother and more efficient.\n\n## The Project Vision\n\nThe idea was born from a common pain point many developers face: maintaining accurate time records while staying focused on coding. I envisioned an application that would:\n- Automatically convert Git commits into Harvest time entries\n- Intelligently distribute hours across commits\n- Provide a modern, user-friendly interface\n- Handle multiple repositories seamlessly\n- Integrate smoothly with Harvest's API\n\n## Why Cursor?\n\nCursor proved to be an invaluable tool throughout the development process. Its AI-powered features and intuitive interface significantly enhanced my development workflow. Here's how Cursor helped at various stages:\n\n### 1. Project Setup and Structure\n\nCursor's intelligent code suggestions helped me set up the project structure efficiently. The application is built with Electron, and Cursor's understanding of the framework made it easier to:\n- Set up the initial boilerplate\n- Organize the codebase into logical components\n- Manage dependencies effectively\n\n### 2. Feature Implementation\n\nSome of the key features where Cursor's AI capabilities shined include:\n\n#### Smart Git Integration\nCursor helped me implement complex Git operations with its context-aware code completion and documentation integration. The IDE's suggestions were particularly helpful when working with:\n- Repository management\n- Commit history processing\n- Branch pattern recognition\n\n#### Harvest API Integration\nWhen implementing the Harvest API integration, Cursor's ability to understand API documentation and suggest relevant code patterns made the process much smoother. This included:\n- API authentication\n- Project and task synchronization\n- Time entry creation\n\n#### User Interface Development\nThe modern Material UI implementation was streamlined thanks to Cursor's:\n- Component suggestions\n- CSS assistance\n- Layout optimization hints\n\n### 3. Error Handling and Testing\n\nCursor's AI capabilities were instrumental in:\n- Identifying potential edge cases\n- Suggesting robust error handling patterns\n- Helping write comprehensive tests\n\n## Key Technical Challenges and Solutions\n\n### 1. Time Distribution Algorithm\nOne of the most complex aspects was developing an algorithm for intelligent hour distribution. Cursor helped by:\n- Suggesting optimal data structures\n- Identifying edge cases in the distribution logic\n- Providing relevant mathematical implementations\n\n### 2. Multi-Repository Management\nManaging multiple Git repositories required careful state management. Cursor assisted with:\n- Efficient data storage patterns\n- Concurrent operation handling\n- Repository settings persistence\n\n### 3. Webhook Integration\nImplementing webhook support for custom message formatting was made easier with Cursor's:\n- API endpoint suggestions\n- JSON parsing implementations\n- Error handling patterns\n\n## Project Structure and Organization\n\nThe final project structure reflects a well-organized application:\n```\nai-harvest-timesheet/\n├── src/\n│   ├── components/    # UI components\n│   ├── services/      # Core services\n│   ├── utils/         # Helper functions\n│   └── config/        # Configuration\n├── docs/             # Documentation\n├── tests/            # Test suites\n└── build/            # Build outputs\n```\n\n## Lessons Learned\n\nThroughout this project, I learned several valuable lessons:\n\n1. **AI-Powered Development**: Cursor's AI capabilities significantly reduced development time and improved code quality.\n\n2. **Code Organization**: The importance of maintaining a clean, modular codebase was reinforced by Cursor's suggestions.\n\n3. **Documentation**: Cursor helped maintain comprehensive documentation alongside the code.\n\n## Conclusion\n\nBuilding AI Harvest Timesheet with Cursor was an enlightening experience that showcased the power of AI-assisted development. The final product is a robust, user-friendly application that solves a real problem for developers.\n\nThe combination of Cursor's intelligent features and my vision for automated time tracking resulted in an application that I'm proud of and that others find valuable. The project is open-source and available on GitHub, where it continues to evolve with community contributions.\n\nFor developers interested in trying out AI Harvest Timesheet or contributing to its development, you can find the project at [GitHub repository link](https://github.com/Tech9Apps/ai-harvest-timesheet).\n\n",
            "url": "https://surajadsul.com/blog/my_journey_with_cursor_ide",
            "title": "Building AI Harvest Timesheet: My Journey with Cursor IDE",
            "summary": "Exploring how Cursor IDE enhanced the development of AI Harvest Timesheet, an application that converts Git commits into Harvest time entries.",
            "date_modified": "2025-02-28T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.com"
            }
        }
    ]
}