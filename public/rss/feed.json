{
    "version": "https://jsonfeed.org/version/1",
    "title": "Suraj Adsul's Blog",
    "home_page_url": "https://surajadsul.me",
    "description": "Articles about software development, technology, and personal experiences",
    "icon": "https://surajadsul.me/images/profile.jpg",
    "author": {
        "name": "Suraj Adsul",
        "url": "https://surajadsul.me"
    },
    "items": [
        {
            "id": "https://surajadsul.me/blog/conquering_the_css_nightmare_as_a_backend_engineer",
            "content_html": "\nIt's been a long time since I last wrote an article, and since this crazy time started, I hope all of you are doing well and coping with the pandemic situation.\n\n## My Journey into UI Development\n\nI started my professional career as a full-stack engineer but mostly focused on backend development. While I used Bootstrap and some UI libraries to quickly build interfaces, I never had full control over the UI. Most people found my work impressive at the time, but deep down, I felt guilty relying on heavy libraries with limited flexibility.\n\nIf you have a good UI/UX sense, these libraries often feel restrictive. So, I attempted to learn CSS—but coming from a backend background, it was far from enjoyable. Writing CSS felt unintuitive, requiring too much effort just to name reusable classes, and yet, the results still felt unstructured.\n\n## The Struggle with CSS\n\nDespite my love for well-designed UIs, writing CSS felt like a nightmare. Learning Vue.js or React was much easier compared to styling. Most backend engineers I knew shared the same fear—CSS seemed difficult because we rarely had to write it from scratch. Instead, we often copy-pasted components and moved on.\n\nI spent countless hours browsing Dribbble and admiring beautiful UIs from companies like Netflix, Stripe, and Spotify, wondering if I would ever be able to create something similar. My frustration led me to tools like Adobe XD and Figma, where I enjoyed designing interfaces. But I still had one major problem: I couldn't translate those designs into code.\n\n## The Turning Point: Discovering Tailwind CSS\n\nFast forward a few years, and Adam Wathan introduced Tailwind CSS. As a long-time Laravel community follower, I decided to give it a shot. At first, using Tailwind felt difficult due to my limited CSS knowledge. However, its utility-first approach made styling more intuitive and enjoyable. For the first time, writing CSS felt fun!\n\nI started implementing different designs using Tailwind, and it was a game-changer. With its content-agnostic classes, I could build UI components much faster without losing control over styling. I finally had the power of raw CSS without the usual struggles.\n\n## Cloning Websites and Mastering UI\n\nTo practice, I began cloning popular websites like Spotify, Myntra, Facebook, Hotstar, Netflix, and Amazon. This approach taught me advanced CSS concepts like animations, blending modes, and responsiveness. Thanks to Tailwind CSS, replicating UIs became an enjoyable learning experience instead of a frustrating chore.\n\nInitially, it took me 2-3 days to clone a website. But with practice, I could recreate complex UIs in just a few hours. My fear of CSS was finally gone!\n\n## Why Tailwind CSS?\n\n### Pros:\n- Provides utility classes with full UI control.\n- Intuitive syntax that reduces cognitive load and boosts productivity.\n- Fun and easy to write.\n- Includes PurgeCSS, ensuring only used classes are included in the production build.\n- Encourages component-based thinking.\n- Well-thought-out utility classes and color palettes.\n- Fully customizable.\n- Simplifies animations, gradients, and blending modes.\n- Built-in dark mode support.\n- Just-In-Time (JIT) mode for arbitrary styles.\n- Supports presets for maintaining design consistency across projects.\n\n### Cons:\n- Results in numerous classes in your HTML.\n  - However, with modern JavaScript frameworks and Blade templates, component-based structuring helps mitigate this issue.\n- Still requires fundamental CSS knowledge.\n  - If you just want a quick prototype without dealing with CSS, Bootstrap or Foundation may be better options.\n\nThat said, I still recommend Tailwind CSS, even for prototyping. There are plenty of ready-made Tailwind component libraries available to speed up development while maintaining full UI control.\n\n## Useful Tailwind CSS Resources\n\n- **Official Tailwind UI (Paid)**: [https://tailwindui.com/](https://tailwindui.com/)\n- **Free Tailwind Component Libraries**:\n  - [https://tailblocks.cc/](https://tailblocks.cc/)\n  - [https://merakiui.com/](https://merakiui.com/)\n  - [https://www.creative-tim.com/learning-lab/tailwind-starter-kit/presentation](https://www.creative-tim.com/learning-lab/tailwind-starter-kit/presentation)\n\n## Final Thoughts\n\nIf you're like me—someone who loves great UI but struggled with CSS—I encourage you to try Tailwind CSS. Work on sample projects, find inspiration on Dribbble, and start experimenting. It may just change the way you approach frontend development, as it did for me.\n\n\n",
            "url": "https://surajadsul.me/blog/conquering_the_css_nightmare_as_a_backend_engineer",
            "title": "Conquering the CSS Nightmare as a Backend Engineer",
            "summary": "A journey from struggling with CSS to mastering UI development using Tailwind CSS. Learn how a backend engineer overcame the fear of styling and embraced frontend design.",
            "date_modified": "2021-05-29T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.me"
            }
        },
        {
            "id": "https://surajadsul.me/blog/creating_worklogs_using_cursor_ai_editor",
            "content_html": "\nKeeping a structured and detailed worklog is essential for tracking progress, maintaining accountability, and improving productivity. The Cursor AI editor provides an efficient way to maintain daily worklogs with a predefined structure. This guide outlines the best practices for creating and managing worklogs using Cursor AI.\n\n## Worklog Format and Structure\nEach daily worklog should follow a consistent structure for clarity and ease of reference. The format should be as follows:\n\n```markdown\n# Daily Worklog - [YYYY-MM-DD]\n\n## Summary\n- Brief overview of the day's main accomplishments\n- Key decisions made\n- Any blockers encountered\n\n## Tasks Completed\n- [x] Task 1\n  - Details/Implementation notes\n- [x] Task 2\n  - Details/Implementation notes\n\n## In Progress\n- [ ] Ongoing task 1\n  - Current status\n  - Next steps\n\n## Blockers/Issues\n- List any blockers or issues encountered\n- Include potential solutions or workarounds\n\n## Notes\n- Additional important information\n- Links to relevant resources\n- Meeting notes or decisions\n\n## Tomorrow's Plan\n- [ ] Planned task 1\n- [ ] Planned task 2\n\n## Time Tracking\n- Task 1: X hours\n- Task 2: Y hours\n\n\n## Worklog Guidelines\nTo maintain consistency and organization, adhere to these guidelines:\n\n1. **Date Format**: Always use `YYYY-MM-DD` (e.g., `2024-03-21`).\n2. **Storage Location**: Store worklogs in the directory structure `docs/worklogs/YYYY-MM/YYYY-MM-DD.md`.\n3. **Naming Convention**: Use lowercase filenames and adhere to the `YYYY-MM-DD.md` format.\n4. **Task Status**: Use `- [ ]` for incomplete tasks and `- [x]` for completed tasks.\n5. **Time Tracking**: Always include time spent on major tasks for better time management.\n6. **Links**: Include relevant links such as PRs, documentation, or meeting notes.\n7. **Blockers**: Clearly document any blockers, their status, and any attempted solutions.\n\n## Best Practices\nTo ensure your worklogs remain useful and effective, follow these best practices:\n\n1. **Start at the Beginning of the Day**: Outline planned tasks and priorities.\n2. **Update Throughout the Day**: Keep track of completed tasks and new developments.\n3. **Finalize at the End of the Day**: Review and ensure completeness before storing.\n4. **Include Technical Details**: Be specific about implementations, changes, and issues faced.\n5. **Reference Relevant Tickets/Issues**: Include issue numbers and descriptions where applicable.\n6. **Maintain Professionalism**: Use clear and professional language.\n7. **Document Decisions and Rationale**: Ensure clarity on why certain decisions were made.\n\n```\n\n## Conclusion\nBy using the Cursor AI editor to maintain structured and detailed worklogs, you can enhance productivity and ensure better documentation of your daily work. Following the outlined structure, guidelines, and best practices will make worklogs more effective and easier to review in the future.\n\n",
            "url": "https://surajadsul.me/blog/creating_worklogs_using_cursor_ai_editor",
            "title": "Creating Worklogs Using Cursor AI Editor",
            "summary": "Learn how to efficiently create and manage daily worklogs using the Cursor AI editor with a structured approach.",
            "date_modified": "2025-03-02T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.me"
            }
        },
        {
            "id": "https://surajadsul.me/blog/integrating_tailwind_css_in_a_legacy_project_using_the_standalone_executable",
            "content_html": "\nTailwind CSS is a powerful utility-first CSS framework that has gained immense popularity for its flexibility and ease of use. However, integrating it into a legacy project—especially one that already has existing CSS and doesn’t use node modules—can seem daunting. \n\n## The Challenge\nLegacy projects often come with their own set of constraints. In this case, we’re dealing with:\n\n- Existing CSS files that already style the project.\n- No node modules, meaning no npm or Node.js environment.\n- The need to integrate Tailwind CSS without disrupting the current setup.\n\nGiven these constraints, the standard installation method for Tailwind (via npm) isn’t an option. But don’t worry—there’s a solution that fits this scenario perfectly.\n\n\n## Implementation Approach\n\n### 1. Download the Standalone CLI\nVisit the [Tailwind CSS Releases page](https://github.com/tailwindlabs/tailwindcss/releases) and download the standalone CLI executable for your platform (e.g., macOS, Windows, Linux). Make sure to choose the latest version.\n\nOnce downloaded, ensure the file has executable permissions.\n```\nchmod +x tailwindcss\n```\n\n### 2. Project Structure\n\nA structured approach to organizing Tailwind integration:\n\n```\nproject-root/\n├── tailwindcss (executable)\n├── public/\n│   └── css/\n│       ├── tailwind-input.css\n│       └── tailwind.css (generated)\n└── Makefile\n```\n\n### 3. Configuration Files\n\nA `tailwind-input.css` file can be created as the main configuration:\n\n```css\n@import 'tailwindcss/theme.css';\n@import 'tailwindcss/preflight.css';\n@import 'tailwindcss/utilities.css';\n@import './fonts.css' layer(base);\n@plugin \"@tailwindcss/aspect-ratio\";\n\n@theme {\n    --font-primary: Arial;\n    --font-secondary: Helvetica;\n    /* Custom theme variables */\n}\n\n@layer utilities {\n    /* Custom utility classes */\n    .container-custom {\n        margin-inline: auto !important;\n        width: 100% !important;\n        max-width: 640px !important;\n    }\n}\n```\n\n### 4. Build Process\n\nA simple Makefile can be used to manage Tailwind CSS compilation:\n\n```makefile\n.PHONY: watch build\n\nwatch:\n\t./tailwindcss -i ./public/css/tailwind-input.css -o ./public/css/tailwind.css --watch\n\nbuild:\n\t./tailwindcss -i ./public/css/tailwind-input.css -o ./public/css/tailwind.css --minify\n```\n\nCommands:\n- `make watch`: Watches for changes during development\n- `make build`: Creates a minified production version\n\n### 4. Integration with HTML\n\nThe compiled CSS file can be included in templates:\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/tailwind.css?version=1.0.5\" />\n```\n\n## Key Benefits of This Approach\n\n1. **No npm Dependencies**: Avoids adding npm and its dependency tree.\n2. **Simple Build Process**: Requires only a single executable and a Makefile.\n3. **Easy Version Control**: The standalone executable can be managed separately.\n4. **Fast Compilation**: Optimized performance with the standalone executable.\n\n## Scoped Usage\n\nA clear approach to scope Tailwind CSS usage ensures maintainability:\n\n```markdown\nTailwindCSS is used exclusively in specific directories. \nFor other files, standard CSS is maintained.\n```\n\nThis scoped approach helps:\n- Maintain boundaries between legacy and modern CSS\n- Gradually introduce Tailwind CSS without disrupting existing styles\n- Keep the codebase structured and maintainable\n\n## Example Usage\n\nAn example of using Tailwind CSS:\n\n```html\n<div class=\"header-blue flex pl-10 font-primary text-white bg-gray-800 h-32 relative\">\n  <div class=\"absolute left-0 top-0 h-full w-5 bg-pattern bg-no-repeat bg-center\"></div>\n  <h1 class=\"ml-8 text-4xl md:text-5xl\">Sample Header</h1>\n</div>\n```\n\n## Best Practices\n\n1. **Version Control**: Track compiled CSS file versions using query parameters.\n2. **Scoped Implementation**: Use Tailwind CSS in designated directories.\n3. **Custom Utilities**: Create reusable utility classes as needed.\n4. **Build Process**: Use a Makefile for consistent builds across environments.\n\n## Potential Pitfalls\nWatch out for these common issues:\n\n- Specificity Issues: Tailwind’s utility classes have low specificity. If your existing CSS uses high-specificity selectors (e.g., IDs or nested rules), they might override Tailwind styles. Including `tailwind.css` after other CSS files helps mitigate this.\n\n## Conclusion\n\nUsing the Tailwind CSS standalone executable is an efficient way to modernize a legacy project's CSS without introducing complex dependencies. This approach enables the advantages of utility-first CSS while maintaining simplicity and compatibility with existing styles.\n\nOfficial Documentation: [TailwindCSS standalone-cli](https://tailwindcss.com/blog/standalone-cli)\n\nThe key to success is maintaining clear boundaries between legacy and modern CSS patterns, allowing a gradual transition to modern styling practices while keeping the codebase structured and manageable.\n\n",
            "url": "https://surajadsul.me/blog/integrating_tailwind_css_in_a_legacy_project_using_the_standalone_executable",
            "title": "Integrating Tailwind CSS in a Legacy Project Using the Standalone Executable",
            "summary": "A step-by-step guide on integrating Tailwind CSS into a legacy project using the standalone executable. Learn how to set up the project structure, configure styles, and streamline the build process without relying on npm.",
            "date_modified": "2025-03-01T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.me"
            }
        },
        {
            "id": "https://surajadsul.me/blog/leveraging_ai_for_smarter_github_pr_reviews_with_cursor",
            "content_html": "\n## Introduction\n\nCode reviews are a crucial part of the software development process, but they can be time-consuming and sometimes inconsistent. In this post, I'll show you how to use Cursor, an AI-powered IDE, to create automated yet intelligent PR reviews on GitHub. This approach ensures high standards while saving valuable developer time.\n\n## Setting Up the Review System\n\n### Prerequisites\n- Cursor IDE installed\n- GitHub CLI configured\n- Python installed\n- GitHub token set up\n\n## Adding a Prompt in Cursor Rules\n\nCreate a file named `github-pr-review.mdc` in the `rules` directory and add the following prompt:\n\nHere is the full Gist: [github-pr-review.mdc](https://gist.github.com/SurajAdsul/66a594b951a841c3ede07e2e6715c418#file-github-pr-review-mdc)\n\nAdditionally, create a `tools` directory and add the following two scripts so that Cursor can utilize them. Adjust the paths as needed for your project:\n- [fetch_pr_diff.py](https://gist.github.com/SurajAdsul/66a594b951a841c3ede07e2e6715c418#file-fetch_pr_diff-py)\n- [gh-pr-comment.sh](https://gist.github.com/SurajAdsul/66a594b951a841c3ede07e2e6715c418#file-gh-pr-comment-sh)\n\n## Performing Code Reviews\n\nIn Cursor’s agent mode, add the following prompt along with the PR ID you want to review. Be sure to select the Claude models for code reviews, as they perform best for coding-related tasks.\n\n![Cursor PR Review](</blog/Screenshot 2025-03-22 at 7.38.09 PM.png>)\n\nCursor will analyze the diff and generate a series of commands to add comments to the GitHub PR. If you are using YOLO mode, Cursor will automatically post all the review comments. Otherwise, it will prompt you with commands that you need to run manually to add the review comments. Here's an example of how it might look:\n\n![Cursor Review Commands](</blog/Screenshot 2025-03-22 at 7.44.38 PM.png>)\n\nYou can review the PR and remove any unnecessary comments as needed.\n\n## The Review Framework\n\nThe system is designed to act as an experienced senior software engineer reviewing Pull Requests, focusing on:\n- Code quality improvements\n- Potential bug detection\n- Security issue identification\n- Actionable code suggestions\n\n## How It Works\n\n### 1. PR Diff Structure\n\nThe system processes PR diffs in a structured format:\n```\n## File: 'src/example.py'\n\n@@ ... @@ def function():\n__new hunk__\n11  unchanged line\n12 +new code added\n13  another unchanged line\n__old hunk__\n unchanged line\n-removed code\n unchanged line\n```\n\nKey components:\n- `__new hunk__`: Shows the updated code section\n- `__old hunk__`: Displays removed code\n- Line numbers for easy reference\n- Prefix symbols:\n  - `+`: New code added\n  - `-`: Code removed\n  - ` `: Unchanged code\n\n### 2. Review Focus\n\nThe review system specifically targets:\n- New code additions (lines with `+` prefix)\n- Actionable improvements\n- Concrete issues rather than style preferences\n\n## Best Practices\n\n### What the System Reviews:\n- ✅ Code quality issues\n- ✅ Potential bugs\n- ✅ Security vulnerabilities\n- ✅ Meaningful code improvements\n\n### What the System Ignores:\n- ❌ Code formatting\n- ❌ Style preferences\n- ❌ Documentation requests\n- ❌ Implementation suggestions\n- ❌ Duplicate comments\n\n## Implementation\n\n### Using the Tools\n\n1. Fetch PR diff:\n```bash\ncd your-repo && python3 ../tools/fetch_pr_diff.py\n```\n\n2. Add review comments:\n```bash\ncd your-repo && ../tools/gh-pr-comment.sh pr review <PR_NUMBER> --comment -b \"review comment\" --path <FILE_PATH> --line <LINE_NUMBER>\n```\n\n## Key Benefits\n\n1. **Consistency**: Ensures a standardized review approach\n2. **Focus**: Addresses only meaningful code changes\n3. **Efficiency**: Automates the review process intelligently\n4. **Context-Aware**: Reviews code in its relevant context without assumptions\n\n## Best Practices for Review Integration\n\n1. **Review Scope**: The system only reviews code within the PR diff.\n2. **Actionable Feedback**: All comments are specific and implementable.\n3. **No Assumptions**: Reviews are based solely on visible code.\n4. **Unique Comments**: Avoids duplicate or redundant feedback.\n\n## Caution\nThis system is relatively new and still evolving. You may need to adjust paths based on your project setup and requirements. Use Claude models in Cursor whenever performing code reviews for the best results. Depending on the LLM’s context, its performance may vary—sometimes excelling, and other times being less effective.\n\n## Conclusion\n\nBy integrating this AI-powered PR review system into your development workflow with Cursor, you can maintain high code quality standards while significantly reducing the time spent on routine code reviews. The system focuses on actionable, meaningful feedback, ensuring developers receive valuable input without getting bogged down by stylistic or trivial concerns. \n\nWhile this automated system is powerful, it works best as a complement to human review rather than a replacement. Use it to catch common issues and maintain consistency while allowing human reviewers to focus on higher-level architectural and design considerations.\n\n## Next\n[Check how to fix Gihub PR review comments in Cursor](https://www.surajadsul.me/snippets/extract_pr_review_comments_for_fixing_issues_in_cursor)\n\n\n\n\n",
            "url": "https://surajadsul.me/blog/leveraging_ai_for_smarter_github_pr_reviews_with_cursor",
            "title": "Leveraging AI for Smarter GitHub PR Reviews with Cursor",
            "summary": "Code reviews are a crucial part of the software development process, but they can be time-consuming and sometimes inconsistent. Today, I'll show you how to use Cursor, an AI-powered IDE, to create automated yet intelligent PR reviews on GitHub that maintain high standards while saving valuable developer time",
            "date_modified": "2025-03-22T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.me"
            }
        },
        {
            "id": "https://surajadsul.me/blog/my_journey_with_cursor_ide",
            "content_html": "\nAs a developer who values both productivity and accuracy in time tracking, I embarked on a journey to create AI Harvest Timesheet, an innovative application that bridges the gap between Git commits and Harvest time entries. In this blog post, I'll share my experience building this application using Cursor, a cutting-edge IDE that made the development process smoother and more efficient.\n\n## The Project Vision\n\nThe idea was born from a common pain point many developers face: maintaining accurate time records while staying focused on coding. I envisioned an application that would:\n- Automatically convert Git commits into Harvest time entries\n- Intelligently distribute hours across commits\n- Provide a modern, user-friendly interface\n- Handle multiple repositories seamlessly\n- Integrate smoothly with Harvest's API\n\n## Why Cursor?\n\nCursor proved to be an invaluable tool throughout the development process. Its AI-powered features and intuitive interface significantly enhanced my development workflow. Here's how Cursor helped at various stages:\n\n&nbsp;\n\n### 1. Project Setup and Structure\n\nCursor's intelligent code suggestions helped me set up the project structure efficiently. The application is built with Electron, and Cursor's understanding of the framework made it easier to:\n- Set up the initial boilerplate\n- Organize the codebase into logical components\n- Manage dependencies effectively\n\n### 2. Feature Implementation\n\nSome of the key features where Cursor's AI capabilities shined include:\n\n&nbsp;\n\n#### Smart Git Integration\nCursor helped me implement complex Git operations with its context-aware code completion and documentation integration. The IDE's suggestions were particularly helpful when working with:\n- Repository management\n- Commit history processing\n- Branch pattern recognition\n\n#### Harvest API Integration\nWhen implementing the Harvest API integration, Cursor's ability to understand API documentation and suggest relevant code patterns made the process much smoother. This included:\n- API authentication\n- Project and task synchronization\n- Time entry creation\n\n#### User Interface Development\nThe modern Material UI implementation was streamlined thanks to Cursor's:\n- Component suggestions\n- CSS assistance\n- Layout optimization hints\n\n&nbsp;\n\n### 3. Error Handling and Testing\n\nCursor's AI capabilities were instrumental in:\n- Identifying potential edge cases\n- Suggesting robust error handling patterns\n- Helping write comprehensive tests\n\n## Key Technical Challenges and Solutions\n\n### 1. Time Distribution Algorithm\nOne of the most complex aspects was developing an algorithm for intelligent hour distribution. Cursor helped by:\n- Suggesting optimal data structures\n- Identifying edge cases in the distribution logic\n- Providing relevant mathematical implementations\n\n### 2. Multi-Repository Management\nManaging multiple Git repositories required careful state management. Cursor assisted with:\n- Efficient data storage patterns\n- Concurrent operation handling\n- Repository settings persistence\n\n### 3. Webhook Integration\nImplementing webhook support for custom message formatting was made easier with Cursor's:\n- API endpoint suggestions\n- JSON parsing implementations\n- Error handling patterns\n\n## Lessons Learned\n\nThroughout this project, I learned several valuable lessons:\n\n1. **AI-Powered Development**: Cursor's AI capabilities significantly reduced development time and improved code quality.\n\n2. **Code Organization**: The importance of maintaining a clean, modular codebase was reinforced by Cursor's suggestions.\n\n3. **Documentation**: Cursor helped maintain comprehensive documentation alongside the code.\n\n## Conclusion\n\nBuilding AI Harvest Timesheet with Cursor was an enlightening experience that showcased the power of AI-assisted development. The final product is a robust, user-friendly application that solves a real problem for developers.\n\nThe combination of Cursor's intelligent features and my vision for automated time tracking resulted in an application that I'm proud of and that others find valuable. \n\nFor developers interested in trying out AI Harvest Timesheet or contributing to its development, you can find the project at [GitHub repository link](https://github.com/Tech9Apps/ai-harvest-timesheet).\n\n",
            "url": "https://surajadsul.me/blog/my_journey_with_cursor_ide",
            "title": "Building AI Harvest Timesheet: My Journey with Cursor IDE",
            "summary": "Exploring how Cursor IDE enhanced the development of AI Harvest Timesheet, an application that converts Git commits into Harvest time entries.",
            "date_modified": "2025-02-28T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.me"
            }
        },
        {
            "id": "https://surajadsul.me/blog/using_salesforce_mcp_server",
            "content_html": "\n\n\nIn today's fast-paced development environment, efficiently managing and interacting with Salesforce data is crucial. I'm excited to introduce **Salesforce MCP Server**, a powerful tool that bridges the gap between natural language processing and Salesforce development. This package enables developers to interact with Salesforce using natural language through Claude AI integration.\n\n## Getting Started\nInstall the package and check out the [GitHub repository](https://github.com/surajadsul/mcp-server-salesforce) for detailed documentation and examples.\n\nThis is originally developed by [tsmztech](https://github.com/tsmztech). I have just added support for Oauth and support for Cursor IDE with refined documentation.\n\n## What is Salesforce MCP Server?\n\nSalesforce MCP Server is an MCP (Model Context Protocol) server implementation that revolutionizes how developers interact with Salesforce. It allows you to query, modify, and manage your Salesforce objects and records using everyday language rather than complex SOQL queries or API calls.\n\n## Key Features\n\n### 1. Smart Object Management\n- Create and modify custom objects using natural language\n- Intuitive field management and relationship creation\n- Automatic handling of complex metadata operations\n\n### 2. Intelligent Search Capabilities\n- Find objects using partial name matches\n- Search across multiple objects simultaneously\n- SOSL integration for comprehensive search functionality\n\n### 3. Advanced Data Operations\n- Complex queries with relationship support\n- Flexible data manipulation (insert, update, delete, upsert)\n- Cross-object search capabilities\n\n### 4. Developer-Friendly Integration\n- Seamless integration with Cursor IDE and Claude Desktop\n- Multiple authentication methods support\n- Comprehensive error handling and feedback\n\n## Getting Started\n\n### Installation\n```bash\nnpm install -g @surajadsul02/mcp-server-salesforce\n```\n\n### Authentication Options\n\nThe package supports two authentication methods:\n\n1. **Username/Password Authentication**\n   - Traditional username/password with security token\n   - Perfect for development and testing environments\n\n2. **OAuth2 Authentication**\n   - Secure consumer key/secret authentication\n   - Ideal for production environments and enterprise applications\n\n&nbsp;&nbsp;\n\n### Cursor IDE Setup\nConfigure the MCP server in Cursor IDE `.cursor/mcp.json`:\nCheck MCP servers in Cursor settings whether it's acive or not.\nThen in Cursor composer ask it describe the `Account` object.\n\nTry restarting Cursor if it does not work initially.\n\n\n```json\n{\n  \"mcpServers\": {\n    \"salesforce\": {\n      \"command\": \"env\",\n      \"args\": [\n        \"SALESFORCE_USERNAME=your.email@example.com\",\n        \"SALESFORCE_PASSWORD=YourPassword\",\n        \"SALESFORCE_TOKEN=YourToken\",\n        \"npx\",\n        \"-y\",\n        \"@surajadsul02/mcp-server-salesforce\"\n      ]\n    }\n  }\n}\n```\n\n## Real-World Examples\n\nLet's look at some practical examples of how you can interact with Salesforce using natural language:\n\n&nbsp;\n### 1. Object Discovery\n`\n\"Find all objects related to customer service\"\n`\n\nThis simple command will search through your org and find all objects related to customer service, including standard and custom objects.\n\n&nbsp;\n### 2. Schema Analysis\n`\n\"What fields are available in the Account object?\"\n`\n\nGet a comprehensive list of fields, their types, and relationships for any object.\n\n&nbsp;\n### 3. Complex Queries\n`\n\"Show me high-priority Cases with their related Contacts created this month\"\n`\n\nExecute complex SOQL queries without writing a single line of code.\n\n&nbsp;\n### 4. Data Manipulation\n`\n\"Create a Customer Feedback object with Rating and Comments fields\"\n`\n\nPerform metadata operations using simple English instructions.\n\n\n\n\n",
            "url": "https://surajadsul.me/blog/using_salesforce_mcp_server",
            "title": "Using Salesforce MCP Server: Natural Language Interface for Salesforce",
            "summary": "Salesforce MCP Server is an MCP (Model Context Protocol) server implementation that allows you to query, modify, and manage your Salesforce objects and records using everyday language rather than complex SOQL queries or API calls",
            "date_modified": "2025-03-04T00:00:00.000Z",
            "author": {
                "name": "Suraj Adsul",
                "url": "https://surajadsul.me"
            }
        }
    ]
}